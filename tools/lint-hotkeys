#!/usr/bin/env python3
import argparse
import re
from collections import defaultdict
from pathlib import Path, PurePath
from typing import Dict, List, Tuple

from zulipterminal.config.keys import (
    HELP_CATEGORIES,
    KEY_BINDINGS,
    display_keys_for_command,
)


KEYS_FILE = (
    Path(__file__).resolve().parent.parent / "zulipterminal" / "config" / "keys.py"
)
KEYS_FILE_NAME = KEYS_FILE.name
OUTPUT_FILE = Path(__file__).resolve().parent.parent / "docs" / "hotkeys.md"
OUTPUT_FILE_NAME = OUTPUT_FILE.name
SCRIPT_NAME = PurePath(__file__).name
HELP_TEXT_STYLE = re.compile(r"^[a-zA-Z /()',&@#:_-]*$")

# Exclude keys from duplicate keys checking
KEYS_TO_EXCLUDE = ["q", "e", "m", "r", "Esc"]


def read_help_categories() -> Dict[str, List[Tuple[str, List[str]]]]:
    """
    Generate a dict from KEYS_FILE
    key: help category
    value: a list of help texts and key combinations, for each key binding in that help category
    """
    entries_by_category = defaultdict(list)
    for cmd, item in KEY_BINDINGS.items():
        entries_by_category[item["key_category"]].append(
            (item["help_text"], display_keys_for_command(cmd))
        )
    return entries_by_category


ENTRIES_BY_CATEGORY: Dict[str, List[Tuple[str, List[str]]]] = read_help_categories()


def main(fix: bool) -> None:
    if fix:
        generate_hotkeys_file()
    else:
        lint_hotkeys_file()


def lint_hotkeys_file() -> None:
    """
    Lint KEYS_FILE for valid key descriptions (help texts) and key categories,
    check for duplicate key combinations,
    and compare with existing OUTPUT_FILE.
    """
    error_flag = False

    error_flag |= lint_help_categories()
    error_flag |= lint_help_text()

    if error_flag:
        raise SystemExit(
            f"Rerun this command after resolving errors in config/{KEYS_FILE_NAME}"
        )
    else:
        print("No hotkeys linting errors")
        if not OUTPUT_FILE.exists():
            raise SystemExit(
                f"Run './tools/{SCRIPT_NAME} --fix' to generate {OUTPUT_FILE_NAME} file"
            )
        hotkeys_file_string = generate_hotkeys_file_string()
        if not output_file_matches_string(hotkeys_file_string):
            raise SystemExit(
                f"Run './tools/{SCRIPT_NAME} --fix' to update {OUTPUT_FILE_NAME} file"
            )


def lint_help_text() -> bool:
    """
    Lint each keybinding's help text / description for invalid characters
    """
    error_flag = False
    error_message = ""
    for keybinding in KEY_BINDINGS.values():
        help_text = keybinding["help_text"]
        if not re.match(HELP_TEXT_STYLE, help_text):
            key_combinations = " / ".join(keybinding["keys"])
            error_message += (
                f"  ({help_text}) for key combination - [{key_combinations}]\n"
            )
            error_flag = True
    if error_flag:
        print(
            "Help text descriptions should contain only alphabets, spaces and special characters except .\n"
            + error_message
        )
    return error_flag


def lint_help_categories() -> bool:
    """
    Lint help categories by checking each key combination for duplicates
    within the same category
    """
    error_flag = False
    for batch in HELP_CATEGORIES:
        check_duplicate_keys_list: List[str] = []
        for _, key_combinations_list in ENTRIES_BY_CATEGORY[batch]:
            check_duplicate_keys_list.extend(key_combinations_list)
        check_duplicate_keys_list = [
            key for key in check_duplicate_keys_list if key not in KEYS_TO_EXCLUDE
        ]
        duplicate_keys = [
            key
            for key in check_duplicate_keys_list
            if check_duplicate_keys_list.count(key) > 1
        ]
        if len(duplicate_keys) != 0:
            print(
                f"Duplicate key combination for keys {duplicate_keys} for category ({HELP_CATEGORIES[batch]}) detected\n"
            )
            error_flag = True
    return error_flag


def generate_hotkeys_file() -> None:
    """
    Generate OUTPUT_FILE based on help text description and
    shortcut key combinations in KEYS_FILE, grouped by categories
    """
    hotkeys_file_string = generate_hotkeys_file_string()
    output_file_matches_string(hotkeys_file_string)
    with open(OUTPUT_FILE, "w") as hotkeys_file:
        hotkeys_file.write(hotkeys_file_string)
    print(f"Hot Keys list saved in {OUTPUT_FILE}")


def generate_hotkeys_file_string() -> str:
    """
    Construct string in form for output to OUTPUT_FILE based on help text
    description and shortcut key combinations in KEYS_FILE
    """
    hotkeys_file_string = (
        f"<!--- Generated automatically by tools/{SCRIPT_NAME} -->\n"
        "<!--- Do not modify -->\n\n# Hot Keys\n"
    )
    for batch in HELP_CATEGORIES:
        hotkeys_file_string += (
            f"## {HELP_CATEGORIES[batch]}\n"
            "|Command|Key Combination|\n"
            "| :--- | :---: |\n"
        )
        for help_text, key_combinations_list in ENTRIES_BY_CATEGORY[batch]:
            various_key_combinations = " / ".join(
                [
                    " + ".join([f"<kbd>{key}</kbd>" for key in key_combination.split()])
                    for key_combination in key_combinations_list
                ]
            )
            hotkeys_file_string += f"|{help_text}|{various_key_combinations}|\n"
        hotkeys_file_string += "\n"
    return hotkeys_file_string


def output_file_matches_string(hotkeys_file_string: str) -> bool:
    """
    Check if the OUTPUT_FILE exists and matches the generated hotkeys_file_string
    """
    try:
        with open(OUTPUT_FILE) as output_file:
            content_is_identical = hotkeys_file_string == output_file.read()
        if content_is_identical:
            print(
                f"{OUTPUT_FILE_NAME} file already in sync with config/{KEYS_FILE_NAME}"
            )
            return True
        else:
            print(f"{OUTPUT_FILE_NAME} file not in sync with config/{KEYS_FILE_NAME}")
            return False
    except FileNotFoundError:
        print(f"{OUTPUT_FILE_NAME} does not exist")
        return False


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description=f"Lint hotkeys by checking extracted key description style and key "
        f"duplication from config/{KEYS_FILE_NAME} file"
    )
    parser.add_argument(
        "--fix",
        action="store_true",
        help=f"Generate {OUTPUT_FILE_NAME} file by extracting key description and key "
        f"combination from config/{KEYS_FILE_NAME} file",
    )
    args = parser.parse_args()
    main(args.fix)
